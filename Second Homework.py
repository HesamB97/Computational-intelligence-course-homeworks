# -*- coding: utf-8 -*-
"""HW_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l77-oJlZTbFjWRH-wZj5CtScoTclWcx5
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
import random
import pandas

class Hopfield:
  def __init__(self,x):
    self.x=x
    self.w=x.dot(x.T)-x.shape[1]*np.eye(x.shape[0])
    #print(self.w)
  def predict(self,x,max_iters=50):
    a_old=x.copy()
    a_new=x.copy()

    for j in range(max_iters):
      a_new=np.sign(self.w.dot(a_old))
      a_new[a_new==0]=1
      temp=a_new.copy()
      a_new=a_old.copy()
      

      for i in range(len(a_old)):
        if temp[i,0]!=a_old[i,0]:
          a_new[i,0]=temp[i,0]
          break
      
      if np.all(a_new==a_old):
        break
      a_old=a_new.copy()
    return a_new




def sp_noise(image,prob):
    '''
    Add salt and pepper noise to image
    prob: Probability of the noise
    '''
    output = np.zeros(image.shape,np.uint8)
    thres = 1 - prob 
    for i in range(image.shape[0]):
        for j in range(image.shape[1]):
            rdn = random.random()
            if rdn < prob:
                output[i][j] = 0
            elif rdn > thres:
                output[i][j] = 255
            else:
                output[i][j] = image[i][j]
    return output


def image_loader(name):
 img=cv2.resize(name,(180,180))
 _, thresh=cv2.threshold(img,128,255,0)
 image = img # Only for grayscale image
 image[image==-1]=0
 image=image*255

 noise = sp_noise(image,0.4)
 _, noise_img=cv2.threshold(noise,128,255,0)
 cv2.imwrite('sp_noise.jpg', noise_img)

 plt.show()
 plt.figure
 plt.imshow(noise_img, cmap='gray')
 hopin=noise_img/255
 hopin[hopin==0]=-1
 #x=np.array([[1,1,1,-1],[1,-1,-1,1]]).T
 return hopin

img1=cv2.imread('test5.jpg',0)
x=image_loader(img1)
print(x.shape)
hop=Hopfield(x)
out = hop.predict(np.array([x[:,0]]).T)

for j in range(x.shape[0]-1):
  new_column=hop.predict(np.array([x[:,j+1]]).T)
  out = np.append(out, new_column, axis=1)
  


#out=np.reshape(out,(100,100))
out[out==-1]=0
out=out*255
#print(noise_img)
#print(a.shape)

plt.show()
plt.figure
plt.imshow(out, cmap='gray')

img = cv2.imread('test6.jpg', cv2.IMREAD_UNCHANGED)
img=cv2.resize(img,(30,30))
b,g,r = (img[0, 0])

x=np.array([[b],[g],[r]])

for i in range(img.shape[0]):
  for j in range(img.shape[1]):
    b,g,r = (img[i, j])
    new_column=np.array([[b],[g],[r]])
    x = np.append(x, new_column, axis=1)
x=np.delete(x,0,1)

print (r)
print (g)
print (b)
print(x.shape)
plt.show()
plt.figure
plt.imshow(img)

img1 = cv2.imread('test6.jpg', cv2.IMREAD_UNCHANGED)
b,g,r = (img1[0, 0])
print (r)
print (g)
print (b)

import numpy as np
import pandas 
from sklearn.preprocessing import normalize

alpha=0.6999
no_clusters=2
no_feature=3
x = x/x.sum(axis=0,keepdims=1)

w_i=np.random.rand(no_feature,no_clusters)

w_i = w_i/w_i.sum(axis=0,keepdims=1)
w_i_1=w_i[:,0]
w_i_2=w_i[:,1]
for k in range(1000):
  for i in range(img.shape[0]*img.shape[1]):
    D1=w_i_1-x[:,i]
    D1=np.linalg.norm(D1)
    D2=w_i_2-x[:,i]
    D2=np.linalg.norm(D2)
    print(i)
  
    if D1>D2:
     j=2
    else:
     j=1
     if j==1:
      w=w_i[:,j-1]+alpha*(x[:,i]-w_i[:,j-1])
      w1=w[:,np.newaxis]
      #print(w1.shape)
      w2=w_i[:,1]
      w2=w2[:,np.newaxis]
      #print(w2.shape)
     
     #w=np.array([[w1],[w2]])
     #print(i)
     

      w_i_1=w1
      w_i_2=w2
     else:
      w=w_i[:,j-1]+alpha*(x[:,i]-w_i[:,j-1])
      w2=w[:,np.newaxis]
      w2=w_i[0,:]
      w2=w2[:,np.newaxis]
      #w=np.array([[w],[wp]])
      w_i_1=w1
      w_i_2=w2
      #print(w_i.shape)
      #print(i)